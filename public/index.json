
[{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/tags/aiops/","section":"Tags","summary":"","title":"AIOps","type":"tags"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/tags/ansible/","section":"Tags","summary":"","title":"Ansible","type":"tags"},{"content":" Overview # [cite_start]Network automation is no longer just a luxury—it\u0026rsquo;s a requirement for modern infrastructure[cite: 5]. [cite_start]This project demonstrates a transition from traditional \u0026ldquo;screen-scraping\u0026rdquo; to an API-first mindset[cite: 7]. [cite_start]By using Ansible and NETCONF (XML over SSH), configuration changes become faster, safer, and completely idempotent[cite: 7, 8].\nThe Workflow # The automation pipeline follows a structured three-step process to ensure network stability:\n[cite_start]Ansible Control Node: A Linux environment where Ansible and the junipernetworks.junos collection manage the logic[cite: 10]. [cite_start]NETCONF Protocol: The transport mechanism used to push configuration securely[cite: 11]. [cite_start]Candidate Configuration: Ansible pushes a \u0026ldquo;Candidate\u0026rdquo; config, performs a commit check, and then commits the changes to the active state[cite: 12]. Project Structure # [cite_start]A clean automation project keeps variables and logic separated for scalability[cite: 13, 14]:\nFile Purpose ansible.cfg [cite_start]Connection settings [cite: 15] inventory.yml [cite_start]List of switches and connection variables [cite: 15] pb_config_vlans.yml [cite_start]The Playbook containing the automation logic [cite: 15] configs/vlan_data.conf [cite_start]Directory for Junos snippets (the specific changes) [cite: 15] Technical Implementation # 1. Inventory Management # [cite_start]We define the target hosts and the required variables to establish a NETCONF session[cite: 16, 17].\n# inventory.yml all: hosts: access-switch-01:Automating Juniper Networks with Ansible Network automation is no longer just a luxury—it’s a requirement for modern infrastructure. In this post, I’ll walk through how I use Ansible to manage Juniper Junos devices. Unlike traditional \u0026#34;screen-scraping\u0026#34; methods, Juniper switches are built with an API-first mindset, allowing Ansible to communicate via NETCONF (XML over SSH). This makes changes faster, safer, and completely idempotent. The Workflow Ansible Control Node: A Linux machine where Ansible and the junipernetworks.junos collection are installed. NETCONF: The protocol used to push configuration. Candidate Configuration: Ansible pushes a \u0026#34;Candidate\u0026#34; config, performs a commit check, and then commits the changes. Project Structure A clean automation project keeps variables and configurations separated: . ├── ansible.cfg # Connection settings ├── inventory.yml # List of switches ├── pb_config_vlans.yml # The Playbook └── configs/ # Directory for Junos snippets └── vlan_data.conf # The specific change to apply 1. The Inventory (inventory.yml) We define our switches and the required variables to connect via NETCONF. all: hosts: access-switch-01: ansible_host: 10.0.1.50 vars: ansible_connection: ansible.netcommon.netconf ansible_network_os: junipernetworks.junos.junos ansible_user: automation_user # Recommended: Use SSH keys or Ansible Vault for passwords 2. The Configuration Snippet (configs/vlan_data.conf) This is standard Junos text format. Ansible will \u0026#34;merge\u0026#34; this into the existing configuration. vlans { Guest_WiFi { vlan-id 100; description \u0026#34;Guest Wireless Network\u0026#34;; } Corporate_Data { vlan-id 200; description \u0026#34;Internal Employees\u0026#34;; } } 3. The Playbook (pb_config_vlans.yml) This is the logic. It loads the file, compares it to the running config, and commits if there’s a difference. --- - name: Configure VLANs on Juniper Switches hosts: all gather_facts: no tasks: - name: Load and Commit VLAN Configuration junipernetworks.junos.junos_config: src: \u0026#34;configs/vlan_data.conf\u0026#34; update: merge comment: \u0026#34;VLAN update via Ansible\u0026#34; register: config_output - name: Show the Diff (What changed?) debug: var: config_output.diff.prepared The Result: Before vs. After Before running the Playbook The switch has no record of these VLANs: user@access-switch-01\u0026gt; show configuration vlans # (Empty or default output) Execution When I run ansible-playbook -i inventory.yml pb_config_vlans.yml, Ansible performs a \u0026#34;diff.\u0026#34; After running the Playbook The switch now has the new hierarchy, and we have an audit log of the change: user@access-switch-01\u0026gt; show configuration vlans Guest_WiFi { vlan-id 100; description \u0026#34;Guest Wireless Network\u0026#34;; } Corporate_Data { vlan-id 200; description \u0026#34;Internal Employees\u0026#34;; } user@access-switch-01\u0026gt; show system commit 0 2024-05-20 14:30:05 UTC by automation_user via netconf VLAN update via Ansible Why this matters By using this \u0026#34;Infrastructure as Code\u0026#34; approach, I can: Version Control: Keep my network configs in GitHub. Consistency: Deploy the same VLANs across 50 switches in the same amount of time it takes to do one. Safety: Use check_mode to see what would happen before actually touching the production network. ansible_host: 10.0.1.50 [cite: 20, 21] vars: ansible_connection: ansible.netcommon.netconf [cite: 22, 23] ansible_network_os: junipernetworks.junos.junos [cite: 24] ansible_user: automation_user [cite: 25] ","date":"11 January 2026","externalUrl":null,"permalink":"/automation/ansible-juniper-vlan-configuration/","section":"Automations","summary":"","title":"Automating Juniper Junos with Ansible and NETCONF","type":"automation"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/tags/automation/","section":"Tags","summary":"","title":"Automation","type":"tags"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/automation/","section":"Automations","summary":"","title":"Automations","type":"automation"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/blog/","section":"Blogs","summary":"","title":"Blogs","type":"blog"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/tags/iac/","section":"Tags","summary":"","title":"IaC","type":"tags"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/series/infrastructure-as-code/","section":"Series","summary":"","title":"Infrastructure as Code","type":"series"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/tags/juniper/","section":"Tags","summary":"","title":"Juniper","type":"tags"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/tags/junos/","section":"Tags","summary":"","title":"Junos","type":"tags"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/tags/mist-ai/","section":"Tags","summary":"","title":"Mist AI","type":"tags"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/tags/netconf/","section":"Tags","summary":"","title":"NETCONF","type":"tags"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/categories/network-automation/","section":"Categories","summary":"","title":"Network Automation","type":"categories"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/tags/networking/","section":"Tags","summary":"","title":"Networking","type":"tags"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/","section":"Professional Portfolio","summary":"","title":"Professional Portfolio","type":"page"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"11 January 2026","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" The Paradigm Shift # For decades, network engineering was defined by reactive troubleshooting. When users complained about “bad Wi-Fi,” “slow applications,” dropped calls, or intermittent disconnects, engineers launched a familiar routine: log into controllers and switches, check interface counters, comb through logs, maybe run a packet capture if the issue stayed long enough. More often than not, the problem had already vanished—or migrated somewhere else in the network.\nWhat made this especially difficult was that these complaints rarely belonged to a single domain. A Wi-Fi issue could stem from a bad cable on an access switch. Slow SaaS performance might be rooted in a WAN path change. Authentication failures could masquerade as wireless instability. Traditional networks forced engineers to troubleshoot each layer in isolation.\nJuniper Mist AI represents a fundamental shift in this operational model. Instead of focusing on devices and reacting to alarms, Mist continuously understands user experience across wireless, wired switching, authentication, and WAN by leveraging cloud-native AI and streaming telemetry. The result is a network that explains why users are having a problem—often before they open a ticket.\nA Real-World Example: When “Bad Wi‑Fi” Isn’t Wi‑Fi # Consider a common scenario: users in one area report unstable Wi‑Fi and frequent disconnects. In a traditional network, the investigation starts with RF—channel plans, power levels, AP utilization. Nothing looks obviously wrong.\nWith Mist, the AI correlates events across domains and reveals the true cause: a high packet loss rate on the wired uplink due to a failing cable on the access switch powering the AP. The wireless experience degraded, not because of RF conditions, but because the physical layer was compromised.\nThis cross-domain visibility is where Mist fundamentally differs. It does not treat wireless, switching, and WAN as separate troubleshooting silos—it treats them as contributors to a single user experience.\nArchitectural Breakdown # Traditional Wireless Architecture # In a traditional environment, the Wireless LAN Controller (WLC) is a physical or virtual bottleneck. Control, management, and policy enforcement are centralized, creating scale limits and single points of failure. Visibility is coarse‑grained—SNMP polls, syslogs, and periodic traps—which leads to lagging indicators and reactive operations.\nKey traits:\nMonolithic WLCs (hardware or VM) Poll‑based telemetry (minutes apart) Manual CLI configuration and change control Troubleshooting driven by symptoms, not root cause Mist AI–Driven Architecture # Mist separates concerns cleanly. The data plane remains distributed at the access points, while the control, analytics, and AI services live in the cloud as elastic microservices. This removes controller bottlenecks and enables near real‑time insight using streaming telemetry.\nKey traits:\nCloud‑native microservices (no traditional controller) Streaming telemetry (seconds or sub‑seconds) Intent‑based configuration Continuous learning from user experience Telemetry: From Polling to Streaming # Traditional networks ask devices how they are doing every few minutes. Mist listens continuously.\nTraditional: SNMP counters, syslogs, and traps provide fragmented, delayed visibility. Mist: Access points stream rich telemetry (RF metrics, client events, application behavior) to the cloud, enabling precise time‑series analysis. This shift is foundational: AI cannot reason accurately without high‑fidelity data.\nAssurance vs Monitoring # A critical conceptual difference is assurance.\nMonitoring tells you device health (AP up/down, CPU, memory). Assurance tells you user experience (time to connect, throughput, roaming success, application performance). Mist measures Service Level Expectations (SLEs) such as:\nSuccessful connections Time to authenticate Time to DHCP Throughput and roaming quality Instead of asking “Is the AP up?”, engineers ask “Did the user succeed?”\nMarvis: The Virtual Network Assistant # Marvis is not a chatbot layered on top of dashboards—it is an operational interface to the AI engine.\nPerforms natural‑language queries (e.g., “Why is Wi‑Fi slow in Building A?”) Correlates RF, wired, authentication, and WAN data Identifies probable root cause with confidence scores Recommends or executes remediation steps This dramatically reduces Mean Time to Resolution (MTTR) by eliminating guesswork.\nClosed‑Loop Automation # Traditional automation focuses on configuration. Mist focuses on outcomes.\nDefine intent (coverage, capacity, performance thresholds) Continuously validate user experience against SLEs Detect anomalies automatically Recommend or apply corrective actions Examples include dynamic RF optimization, identifying misconfigured VLANs, or detecting bad cables—without human initiation.\nOperational Workflow Comparison # Traditional Workflow # User reports an issue Engineer logs into WLC Checks RF stats and client tables Reviews logs across multiple systems Makes a configuration change Waits to see if the issue reoccurs Mist Workflow # Issue detected automatically via SLE violation Root cause analysis generated by AI Engineer validates via Marvis Fix is recommended or auto‑applied System confirms experience recovery Scalability and Resilience # Because Mist services are cloud‑native:\nScale is horizontal and elastic New features arrive continuously without controller upgrades Control plane failures do not impact data forwarding Traditional architectures scale by adding more controllers, increasing cost and complexity.\nSecurity and Trust # Mist integrates security context into assurance:\nDevice fingerprinting Behavioral baselining Visibility into authentication and policy enforcement failures This provides earlier detection of misconfigurations and suspicious behavior compared to log‑only approaches.\nSummary: A Mindset Change for Network Engineers # Automated networks are not about replacing engineers—they are about elevating them.\nFrom device management → experience management From reactive firefighting → proactive assurance From CLI craftsmanship → intent‑driven design Juniper Mist represents a shift where the network explains itself, learns continuously, and helps engineers focus on architecture and outcomes rather than constant troubleshooting.\n","date":"11 January 2026","externalUrl":null,"permalink":"/blog/juniper-mist-vs-traditional/","section":"Blogs","summary":"","title":"The AI Revolution: Juniper Mist vs. Traditional Networking","type":"blog"},{"content":"","date":"19 January 2025","externalUrl":null,"permalink":"/tags/bgp/","section":"Tags","summary":"","title":"BGP","type":"tags"},{"content":"","date":"19 January 2025","externalUrl":null,"permalink":"/tags/evpn/","section":"Tags","summary":"","title":"EVPN","type":"tags"},{"content":" The Scalability Wall # Traditional networks (VLANs) were designed for small, single-building footprints. However, modern environments—Data Centers, high-density campuses, and Cloud—require a shift in logic. We need to scale to thousands of networks, maintain mobility, and ensure compatibility with automation workflows.\nThe Solution: VXLAN # VXLAN (Virtual Extensible LAN) is a tunneling mechanism that carries Ethernet (Layer 2) over IP (Layer 3).\nVLANs: Limited to 4096 IDs; struggle with spanning routed boundaries. VXLAN: Scales to 16 million segments (VNIs) and wraps Ethernet frames inside UDP/IP packets. Analogy: If a VLAN is a local street, the IP network is the highway system. VXLAN is the transport truck that carries your car (L2 Frame) across the highway (L3 Fabric) without the car needing to know the route.\nVXLAN Overview # VLXAN process the following depicts the VLXAN process\nWhy VXLAN Needs EVPN # VXLAN defines the \u0026ldquo;data plane\u0026rdquo; (how the packet is wrapped), but it doesn\u0026rsquo;t solve the \u0026ldquo;control plane\u0026rdquo; problem. Early VXLAN relied on flood-and-learn (multicast), which is inefficient and difficult to automate.\nEVPN (Ethernet VPN) uses Multiprotocol BGP to:\nAdvertise MAC/IP addresses: No more \u0026ldquo;shouting\u0026rdquo; via broadcast. Minimize Flooding: Switches know exactly where endpoints live before traffic even starts moving. Support Automation: BGP-based control planes are highly predictable and programmable. Architecture Overview # Note the BGP control plane peering between VTEPs the following diagram represents a typical Leaf-Spine architecture utilizing EVPN-VXLAN.\n","date":"19 January 2025","externalUrl":null,"permalink":"/blog/from-vlans-to-evpn-vxlan/","section":"Blogs","summary":"","title":"Modern Fabric Evolution: From VLANs to EVPN-VXLAN","type":"blog"},{"content":"","date":"19 January 2025","externalUrl":null,"permalink":"/tags/vxlan/","section":"Tags","summary":"","title":"VXLAN","type":"tags"},{"content":"","date":"20 March 2024","externalUrl":null,"permalink":"/tags/cattools/","section":"Tags","summary":"","title":"CatTools","type":"tags"},{"content":"","date":"20 March 2024","externalUrl":null,"permalink":"/tags/network-administration/","section":"Tags","summary":"","title":"Network Administration","type":"tags"},{"content":" Project Overview # [cite_start]At the University of Texas at San Antonio, I identified an underutilized instance of SolarWinds Kiwi CatTools[cite: 21, 23]. While the university owned the license, the tool had never been programmed to interface with the production environment. I took ownership of the platform to architect a hands-off backup and notification system.\nEngineering Tasks # [cite_start]Device Integration: Configured SSH/Telnet communication profiles for Juniper routers and switches, ensuring secure access to configuration files[cite: 22, 23]. [cite_start]Job Programming: Scripted the \u0026ldquo;Device.Backup.Running Config\u0026rdquo; activities to run on a set rotation, ensuring zero manual intervention was required for disaster recovery preparedness[cite: 22, 23]. [cite_start]SMTP Orchestration: Programmed automated email triggers to provide the engineering team with \u0026ldquo;Success/Failure\u0026rdquo; reports upon completion of every backup cycle[cite: 27, 21]. [cite_start]Inventory Management: Centralized the storage of configuration files, allowing for rapid diff-checking and historical auditing of network changes[cite: 39, 45]. Technical Architecture # The implementation ensures that any change made to the core or edge infrastructure is captured and the team is notified immediately:\ngraph TD A[Kiwi CatTools Scheduler] --\u0026gt; B{Programmed Activities} B --\u0026gt;|SSH| C[Juniper Switches/Routers] B --\u0026gt;|SSH| D[Cisco Infrastructure] C \u0026amp; D --\u0026gt; E[Secure Config Repository] E --\u0026gt; F[Automated Email Notification] F --\u0026gt; G[Network Engineering Team] style A fill:#005a9c,color:#fff style F fill:#f96,stroke:#333 ","date":"20 March 2024","externalUrl":null,"permalink":"/automation/network-backup-tool/","section":"Automations","summary":"Revitalized dormant software assets by programming Kiwi CatTools to automate configuration backups and email reporting for campus-wide network infrastructure.","title":"Operationalizing Network Backups: SolarWinds Kiwi CatTools Implementation","type":"automation"},{"content":"","date":"20 March 2024","externalUrl":null,"permalink":"/tags/solarwinds/","section":"Tags","summary":"","title":"SolarWinds","type":"tags"},{"content":" Professional Summary # I am a collaborative and mission-driven Enterprise DevOps Network Engineer with expertise in troubleshooting, securing, and automating complex networks in fast-paced environments. Currently, as a DevOps Network Engineer at the University of Texas at San Antonio, I focus on eliminating manual processes through Python and Ansible automation while architecting resilient campus infrastructure.\nCore Technical Stack # Automation \u0026amp; DevOps: Red Hat Ansible Automation Platform, Python development, and Linux Fundamentals (RH124). Network Architecture: BGP EVPN/VXLAN implementation, Juniper Mist, and Data Center modernization. Security \u0026amp; Infrastructure: Palo Alto (Panorama), Fortinet (FortiGate), and Checkpoint firewall management. Education \u0026amp; Certifications: B.S. in Computer Network and Cybersecurity, CCNA, and JNCIA/JNCIS-ENT. Project Highlights # From managing international SD-WAN migrations to leading university border firewall reconfigurations for high availability, I deliver tailored solutions that align technical architecture with critical business goals.\n","externalUrl":null,"permalink":"/about/","section":"Professional Portfolio","summary":"","title":"About Me","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]